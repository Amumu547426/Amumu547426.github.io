<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>存储系统 | Haunting</title><meta name="description" content="存储系统存储系统层次结构 速度越快，每位价格就越高 容量越大，每位价格就越低 容量越大，速度越慢  解决方案：采用多种存储器技术，构成多级存储层次结构 程序访问局部性原理时间局部性：程序马上将要用到的信息很可能就是现在正在使用的信息 空间局部性：程序马上将要用到的信息很可能与现在正在使用的信息在存储空间上是相邻的 存储层次性能参数存储容量S 命中率H：CPU访问存储系统时在一级存储中找到所需信息的"><meta name="keywords" content="cache,虚拟存储器"><meta name="author" content="Haunting,jpf547426@gmail.com"><meta name="copyright" content="Haunting"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/amumu547426.github.io/img/logo.png"><link rel="canonical" href="https://amumu547426.github.io/2020/07/12/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin="crossorigin"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="存储系统"><meta property="og:url" content="https://amumu547426.github.io/2020/07/12/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/"><meta property="og:site_name" content="Haunting"><meta property="og:description" content="存储系统存储系统层次结构 速度越快，每位价格就越高 容量越大，每位价格就越低 容量越大，速度越慢  解决方案：采用多种存储器技术，构成多级存储层次结构 程序访问局部性原理时间局部性：程序马上将要用到的信息很可能就是现在正在使用的信息 空间局部性：程序马上将要用到的信息很可能与现在正在使用的信息在存储空间上是相邻的 存储层次性能参数存储容量S 命中率H：CPU访问存储系统时在一级存储中找到所需信息的"><meta property="og:image" content="https://i.loli.net/2020/07/12/cPFZusrglJCTVKz.jpg"><meta property="article:published_time" content="2020-07-12T11:07:14.000Z"><meta property="article:modified_time" content="2020-07-24T14:25:57.956Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/amumu547426.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="next" title="指令级并行开发方法-硬件方法2" href="https://amumu547426.github.io/2020/07/12/%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95-%E7%A1%AC%E4%BB%B6%E6%96%B9%E6%B3%952/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4beb37a543af8fcfbbc2ab3409390e8e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-169236233-1', 'auto');
ga('send', 'pageview');
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/amumu547426.github.io/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/amumu547426/ashe@v1.0.0/mystyl.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://i.loli.net/2020/07/07/U3nb4WG2xQiZRsf.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/amumu547426.github.io/archives/"><div class="headline">文章</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/amumu547426.github.io/tags/"><div class="headline">标签</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/amumu547426.github.io/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/amumu547426.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/amumu547426.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间戳</span></a></div><div class="menus_item"><a class="site-page" href="/amumu547426.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/amumu547426.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 影音</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/amumu547426.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/amumu547426.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/amumu547426.github.io/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/amumu547426.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/amumu547426.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#存储系统"><span class="toc-number">1.</span> <span class="toc-text">存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#存储系统层次结构"><span class="toc-number">1.0.1.</span> <span class="toc-text">存储系统层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序访问局部性原理"><span class="toc-number">1.0.2.</span> <span class="toc-text">程序访问局部性原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储层次性能参数"><span class="toc-number">1.0.3.</span> <span class="toc-text">存储层次性能参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三级存储系统"><span class="toc-number">1.0.4.</span> <span class="toc-text">三级存储系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存储层次四个问题"><span class="toc-number">1.0.5.</span> <span class="toc-text">存储层次四个问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cache"><span class="toc-number">1.1.</span> <span class="toc-text">cache</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#映象规则"><span class="toc-number">1.1.1.</span> <span class="toc-text">映象规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#全相联映象"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">全相联映象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#直接映象"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">直接映象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组相联映象"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">组相联映象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找方法"><span class="toc-number">1.1.2.</span> <span class="toc-text">查找方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#查找目录表"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">查找目录表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并行查找"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">并行查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#单体多字存储器-比较器"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">单体多字存储器+比较器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#替换算法"><span class="toc-number">1.1.3.</span> <span class="toc-text">替换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#随机法"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">随机法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#先进先出法FIFO"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">先进先出法FIFO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最近最少使用法LRU"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">最近最少使用法LRU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU算法的硬件实现"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">LRU算法的硬件实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#写策略"><span class="toc-number">1.1.4.</span> <span class="toc-text">写策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#两种策略"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">两种策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#比较"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#“写”操作时的调块"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">“写”操作时的调块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache性能分析"><span class="toc-number">1.1.5.</span> <span class="toc-text">cache性能分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#改进cache性能"><span class="toc-number">1.2.</span> <span class="toc-text">改进cache性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#降低cache不命中率"><span class="toc-number">1.2.1.</span> <span class="toc-text">降低cache不命中率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#三种类型不命中："><span class="toc-number">1.2.1.1.</span> <span class="toc-text">三种类型不命中：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#增加块大小"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">增加块大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#增加cache容量"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">增加cache容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#提高相联度"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">提高相联度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#伪相联cache（列相联cache）"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">伪相联cache（列相联cache）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#硬件预取"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">硬件预取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编译器控制的预取"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">编译器控制的预取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#编译器优化"><span class="toc-number">1.2.1.8.</span> <span class="toc-text">编译器优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#“牺牲”cache"><span class="toc-number">1.2.1.9.</span> <span class="toc-text">“牺牲”cache</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减少cache不命中开销"><span class="toc-number">1.2.2.</span> <span class="toc-text">减少cache不命中开销</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#采用两级cache"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">采用两级cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#让读不命中优先于写"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">让读不命中优先于写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#写缓冲合并"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">写缓冲合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#请求字处理技术"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">请求字处理技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非阻塞cache技术"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">非阻塞cache技术</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减少命中时间"><span class="toc-number">1.2.3.</span> <span class="toc-text">减少命中时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#容量小、结构简单的cache"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">容量小、结构简单的cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟cache"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">虚拟cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cache访问流水化"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">cache访问流水化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#踪迹cache"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">踪迹cache</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行主存系统"><span class="toc-number">1.3.</span> <span class="toc-text">并行主存系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单体多字存储器"><span class="toc-number">1.3.1.</span> <span class="toc-text">单体多字存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多体交叉存储器"><span class="toc-number">1.3.2.</span> <span class="toc-text">多体交叉存储器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#避免存储器冲突"><span class="toc-number">1.3.3.</span> <span class="toc-text">避免存储器冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#另一种硬件方法"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">另一种硬件方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟存储器"><span class="toc-number">1.4.</span> <span class="toc-text">虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本概念"><span class="toc-number">1.4.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速地址转换技术"><span class="toc-number">1.4.2.</span> <span class="toc-text">快速地址转换技术</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/07/12/cPFZusrglJCTVKz.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/amumu547426.github.io/">Haunting</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/amumu547426.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/amumu547426.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间戳</span></a></div><div class="menus_item"><a class="site-page" href="/amumu547426.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/amumu547426.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 影音</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/amumu547426.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/amumu547426.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page" href="/amumu547426.github.io/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/amumu547426.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/amumu547426.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">存储系统</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-07-12 19:07:14"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-07-12</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-07-24 22:25:57"><i class="fas fa-history fa-fw"></i> 更新于 2020-07-24</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/amumu547426.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">计算机体系结构</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">5.8k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 17 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h3 id="存储系统层次结构"><a href="#存储系统层次结构" class="headerlink" title="存储系统层次结构"></a>存储系统层次结构</h3><ul>
<li>速度越快，每位价格就越高</li>
<li>容量越大，每位价格就越低</li>
<li>容量越大，速度越慢</li>
</ul>
<p>解决方案：采用多种存储器技术，构成多级存储层次结构</p>
<h3 id="程序访问局部性原理"><a href="#程序访问局部性原理" class="headerlink" title="程序访问局部性原理"></a>程序访问局部性原理</h3><p>时间局部性：程序马上将要用到的信息很可能就是现在正在使用的信息</p>
<p>空间局部性：程序马上将要用到的信息很可能与现在正在使用的信息在存储空间上是相邻的</p>
<h3 id="存储层次性能参数"><a href="#存储层次性能参数" class="headerlink" title="存储层次性能参数"></a>存储层次性能参数</h3><p>存储容量S</p>
<p>命中率H：CPU访问存储系统时在一级存储中找到所需信息的概率</p>
<p>不命中率F：1-H</p>
<p>平均访问时间：<h>T<sub>A</sub></h>=H<h>T<sub>1</sub></h>+(1-H)(<h>T<sub>1</sub></h>+<h>T<sub>M</sub></h>)=<h>T<sub>1</sub></h>+(1-H)<h>T<sub>M</sub></h></p>
<p><h>T<sub>M</sub></h>为不命中开销</p>
<h3 id="三级存储系统"><a href="#三级存储系统" class="headerlink" title="三级存储系统"></a>三级存储系统</h3><p>“cache—主存”和“主存—辅存”构成的系统</p>
<p><img src= "/amumu547426.github.io/img/loading.gif" data-src="https://i.loli.net/2020/07/12/snWE1VNTAcSGIQk.png" alt="三级存储系统.png"></p>
<h3 id="存储层次四个问题"><a href="#存储层次四个问题" class="headerlink" title="存储层次四个问题"></a>存储层次四个问题</h3><ul>
<li>映象规则：当把一个块调入高一层(靠近CPU)存储器时，可以放在哪些位置上</li>
<li>查找算法：当所要访问的块在高一层存储器中时，如何找到该块</li>
<li>替换算法：当发生不命中时，应替换哪一块</li>
<li>写策略：当进行写访问时，应进行哪些操作</li>
</ul>
<h2 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h2><p>cache按块管理，cache主存均被分割成大小相同的块，数据以块为单位调入cache。</p>
<p>基本工作原理图：</p>
<p><img src= "/amumu547426.github.io/img/loading.gif" data-src="https://i.loli.net/2020/07/12/AdXFWHPxLzDZpsc.png" alt="cache.png"></p>
<h3 id="映象规则"><a href="#映象规则" class="headerlink" title="映象规则"></a>映象规则</h3><h4 id="全相联映象"><a href="#全相联映象" class="headerlink" title="全相联映象"></a>全相联映象</h4><p>主存中任一块可以被放置到Cache中的任意一个位置</p>
<p>特点：空间利用率最高，冲突概率最低，实现最复杂</p>
<h4 id="直接映象"><a href="#直接映象" class="headerlink" title="直接映象"></a>直接映象</h4><p>主存中的每一块只能被放置到Cache中唯一的一个位置（循环分配）</p>
<p>例如对于主存的第i块，若cache共有M块，则映射到cache的第j块其中j=i mod(M)</p>
<p>特点：空间利用率最低，冲突概率最高，实现最简单</p>
<h4 id="组相联映象"><a href="#组相联映象" class="headerlink" title="组相联映象"></a>组相联映象</h4><p>主存中的每一块可以被放置到cache中唯一的一个组中的任何一个位置</p>
<p>例如主存第i块映象到cache第k组，则k=i mod(G)，G为cache的组数</p>
<p>特点：是直接映象和全相联的一种折衷</p>
<p>n路组相联：每组中有n个块(n=M/G)，n称为相联度</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>n（路数）</th>
<th>G（组数）</th>
</tr>
</thead>
<tbody>
<tr>
<td>全相联</td>
<td>M</td>
<td>1</td>
</tr>
<tr>
<td>直接映象</td>
<td>1</td>
<td>M</td>
</tr>
<tr>
<td>组相联</td>
<td>1&lt;n&lt;M</td>
<td>1&lt;G&lt;M</td>
</tr>
</tbody>
</table>
</div>
<p>绝大多数计算机的cache：n≤4</p>
<h3 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h3><h4 id="查找目录表"><a href="#查找目录表" class="headerlink" title="查找目录表"></a>查找目录表</h4><p>目录表结构：标识-索引-块内位移，标识和索引构成块地址，索引指示了主存块在cache的位置</p>
<h4 id="并行查找"><a href="#并行查找" class="headerlink" title="并行查找"></a>并行查找</h4><p>相联存储器：目录由<h>2<sup>g</sup></h>(G)个相联存储区构成，每个存储区大小为n×(h+<h>log<sub>2</sub>n</h>))，其中n为路数，h为标识位数</p>
<p><img src= "/amumu547426.github.io/img/loading.gif" data-src="https://i.loli.net/2020/07/12/stQYJUABK5xSIeR.png" alt="相联存储器.png"></p>
<p>根据所查找到的组内块地址，从Cache存储体中读出的多个信息字中选一个，发送给CPU</p>
<h4 id="单体多字存储器-比较器"><a href="#单体多字存储器-比较器" class="headerlink" title="单体多字存储器+比较器"></a>单体多字存储器+比较器</h4><p>以4路组相联为例</p>
<p><img src= "/amumu547426.github.io/img/loading.gif" data-src="https://i.loli.net/2020/07/12/XZWrlVS6qmRI2ie.png" alt="四路组相联.png"></p>
<p>根据索引找对应的组，用标识与组内的四路标识比较从而判断是否命中</p>
<p>不必采用相联存储器，直接用按地址访问的存储器即可</p>
<h3 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h3><p>直接映象cache中的替换算法很容易，因为只有一个块，别无选择，在组相联和全相联中有多种选择</p>
<h4 id="随机法"><a href="#随机法" class="headerlink" title="随机法"></a>随机法</h4><p>随机选取一个块替换，实现简单</p>
<h4 id="先进先出法FIFO"><a href="#先进先出法FIFO" class="headerlink" title="先进先出法FIFO"></a>先进先出法FIFO</h4><p>最早进cache的被替换</p>
<h4 id="最近最少使用法LRU"><a href="#最近最少使用法LRU" class="headerlink" title="最近最少使用法LRU"></a>最近最少使用法LRU</h4><p>选择近期最少被访问的块作为被替换的块，命中率较高</p>
<p>模拟数据表明，对于容量很大的cache，LRU和随机法的命中率差别不大</p>
<h4 id="LRU算法的硬件实现"><a href="#LRU算法的硬件实现" class="headerlink" title="LRU算法的硬件实现"></a>LRU算法的硬件实现</h4><ul>
<li><p>堆栈法</p>
<ul>
<li>一个堆栈，栈底为早被访问的块地址，栈顶是刚刚被访问的块地址。cache命中时，通过用块地址进行相联查找，在堆栈中找到相应的元素出栈并压入栈顶。cache不命中时把本次访问的块地址压栈，若栈满则把栈底弹出再把本次访问的块地址压栈</li>
</ul>
</li>
<li><p>比较对法</p>
<ul>
<li><p>让各块两两组合，构成比较对。每一个比较对用一个触发器的状态来表示它所相关的两个块最近一次被访问的远近次序，再经过门电路就可找到LRU块</p>
<p>例：假设有A、B、C三个块，组成三对AB、AC、BC，<h>T<sub>AB</sub></h>为1表示A比B更近被访问过，则当<h>T<sub>AB</sub></h>=1且<h>T<sub>BC</sub></h>=1时表示C是最久未被访问的块地址</p>
<p>当组内块数较多时，可用多级状态位技术减少所需的硬件量。</p>
<p>例：组内16块，可分为群、对、行3级，分为4群，每群两对，每对两行</p>
<p>则选LRU群需要6（n×(n-1)/2）个触发器，每个群选LRU对需要 一个触发器，共需4个；每个对选LRU块需要一个触发器，一共8对需要8个，共需18个</p>
</li>
</ul>
</li>
</ul>
<h3 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h3><p>“写”操作必须在确认是命中后才可进行，“写”有可能导致cache和主存内容的不一致</p>
<h4 id="两种策略"><a href="#两种策略" class="headerlink" title="两种策略"></a>两种策略</h4><ul>
<li>写直达法<ul>
<li>执行“写”操作时，不仅写入cache，而且也写入下一级存储器</li>
</ul>
</li>
<li>写回法<ul>
<li>执行“写”操作时，只写入cache。仅当cache中相应的块被替换时，才写回主存</li>
</ul>
</li>
</ul>
<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>写回法速度快，使用的存储器带宽较低；写直达法易实现，一致性好</p>
<p>采用写直达法时，若在进行“写”操作的过程中CPU必须等待，直到“写”操作结束，则称CPU写停顿，可以采用写缓冲器来优化</p>
<h4 id="“写”操作时的调块"><a href="#“写”操作时的调块" class="headerlink" title="“写”操作时的调块"></a>“写”操作时的调块</h4><ul>
<li>按写分配（写时取）（写回法采用）<ul>
<li>写不命中时，先把所写单元块调入cache再写入</li>
</ul>
</li>
<li>不按写分配（绕写法）（写直达法采用）<ul>
<li>写不命中时，直接写入下一级存储器而不调块</li>
</ul>
</li>
</ul>
<h3 id="cache性能分析"><a href="#cache性能分析" class="headerlink" title="cache性能分析"></a>cache性能分析</h3><ul>
<li><p>平均访存时间：</p>
<ul>
<li><p>平均访存时间 ＝ 命中时间＋不命中率 × 不命中开销</p>
<p>不命中开销＝不命中周期数（停顿）× 时钟周期时间</p>
</li>
</ul>
</li>
<li><p>程序执行时间：</p>
<ul>
<li><p>CPU时间＝（CPU执行周期数+存储器停顿周期数）× 时钟周期时间</p>
<p>​               ＝（CPU执行周期数+访存次数×不命中率×不命中开销）× 时钟周期时间</p>
<p>​               ＝IC ×（<h>CPI<sub>exe</sub></h>+每条指令平均访存次数×不命中率×不命中开销）× 时钟周期时间</p>
<p><h>CPI<sub>exe</sub></h>越低，固定周期数的cache不命中开销的相对影响就越大</p>
</li>
</ul>
</li>
</ul>
<h2 id="改进cache性能"><a href="#改进cache性能" class="headerlink" title="改进cache性能"></a>改进cache性能</h2><h3 id="降低cache不命中率"><a href="#降低cache不命中率" class="headerlink" title="降低cache不命中率"></a>降低cache不命中率</h3><h4 id="三种类型不命中："><a href="#三种类型不命中：" class="headerlink" title="三种类型不命中："></a>三种类型不命中：</h4><ul>
<li>强制性不命中：当第一次访问一个块时，该块不在cache中，需从下一级存储器中调入cache，这就是强制性不命中。(冷启动不命中，首次访问不命中）</li>
<li>容量不命中：如果程序执行时所需的块不能全部调入Cache中，则发生容量缺失，随后再被调入。这种不命中称为容量不命中</li>
<li>冲突不命中：在组相联或直接映象cache中，若太多的块映象到同一组(块)中，则会出现该组中某个块被别的块替换(即使别的组或块有空闲位置)，然后又被重新访问的情况。这就是发生了冲突不命中。(碰撞不命中，干扰不命中)</li>
</ul>
<p>有以下结论：</p>
<ol>
<li>相联度越高，冲突不命中就越少</li>
<li>强制性不命中和容量不命中不受相联度的影响</li>
<li>强制性不命中不受cache容量的影响，但容量不命中却随着容量的增加而减少</li>
</ol>
<p>根据以上结论，减少三种不命中的方法：</p>
<ul>
<li>强制性不命中：增加块大小，预取（本身很少）</li>
<li>容量不命中：增加容量（抖动现象：cache同一个组内块被反复地替换）</li>
<li>冲突不命中：提高相联度（理想：全相联）</li>
</ul>
<h4 id="增加块大小"><a href="#增加块大小" class="headerlink" title="增加块大小"></a>增加块大小</h4><p>对于给定的Cache容量，当块大小增加时，不命中率开始是下降，后来反而上升了</p>
<p>由于增加块大小会减少cache中块的数目，所以有可能会增加冲突不命中。cache容量越大，使不命中率达到最低的块大小就越大。增加块大小也会增加不命中的开销</p>
<h4 id="增加cache容量"><a href="#增加cache容量" class="headerlink" title="增加cache容量"></a>增加cache容量</h4><p>缺点：增加成本，可能增加命中时间</p>
<h4 id="提高相联度"><a href="#提高相联度" class="headerlink" title="提高相联度"></a>提高相联度</h4><p>采用相联度超过8的方案的实际意义不大，提高相联度是以增加命中时间为代价的</p>
<p>2:1 cache经验规则：容量为N的直接映象cache的不命中率和容量为N/2的两路组相联cache的不命中率差不多相同</p>
<h4 id="伪相联cache（列相联cache）"><a href="#伪相联cache（列相联cache）" class="headerlink" title="伪相联cache（列相联cache）"></a>伪相联cache（列相联cache）</h4><p>既有直接映象的命中时间小优点，也有组相联的不命中率低的优点</p>
<p>基本思想：在逻辑上把直接映象cache的空间上下平分为两个区。对于任何一次访问，伪相联cache先按直接映象cache的方式去处理（快速命中）。若命中，则其访问过程与直接映象cache的情况一样。若不命中，则再到另一区相应的位置去查找。若找到，则发生了伪命中，否则就只好访问下一级存储器</p>
<p><img src= "/amumu547426.github.io/img/loading.gif" data-src="https://i.loli.net/2020/07/12/2GxJChKEUDs4Am8.png" alt="伪相联.png"></p>
<p>出现伪命中时把最近访问过的块放在第一位置</p>
<h4 id="硬件预取"><a href="#硬件预取" class="headerlink" title="硬件预取"></a>硬件预取</h4><p>指令和数据都可以预取，可放入cache或外缓冲器，指令预取通常由cache之外的硬件完成。通过指令预取或数据预取或指令加数据预取可以捕获不命中。预取应利用存储器的空闲带宽，不能影响对正常不命中的处理，否则可能会降低性能</p>
<h4 id="编译器控制的预取"><a href="#编译器控制的预取" class="headerlink" title="编译器控制的预取"></a>编译器控制的预取</h4><p>在编译时加入预取指令，在数据被用到之前发出预取请求</p>
<p>按预取数据存放位置分</p>
<ul>
<li>寄存器预取：把数据取到寄存器</li>
<li>cache预取：只取数据到cache</li>
</ul>
<p>按预取处理方式分</p>
<ul>
<li>故障性预取：在预取时，若出现虚地址故障或违反保护权限，就会发生异常</li>
<li>非故障性预取（非绑定预取）：在遇到这种情况时则不会发生异常，因为这时它会放弃预取，转变为空操作</li>
</ul>
<p>预取数据时，处理器应能继续执行。编译器控制预取的目的是使执行指令和读取数据能重叠执行</p>
<p>循环是预取优化的主要对象</p>
<ul>
<li>不命中开销小时：循环体展开1～2次</li>
<li>不命中开销大时：循环体展开许多次</li>
</ul>
<p>注意每次预取需要花费一条指令的开销，要确保这种开销要小于带来的收益。编译器可以通过把重点放在那些可能会导致不命中的访问上，使程序避免不必要的预取，从而较大程度地减少平均访存时间</p>
<h4 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h4><p>基本思想：通过对软件进行优化来降低不命中率</p>
<ul>
<li><p>程序代码和数据重组</p>
<ul>
<li>把一个程序中的过程重新排序，就可能会减少冲突不命中，从而降低指令不命中率</li>
<li>如果编译器知道一个分支指令很可能会成功转移，则可以用以下两步来改善空间局部性<ul>
<li>将转移目标处的基本块和紧跟着该分支指令后的基本块进行对调</li>
<li>把该分支指令换为操作语义相反的分支指令</li>
</ul>
</li>
</ul>
</li>
<li><p>数组合并：将本来相互独立的多个数组合并成为一个复合数组，以提高访问它们的局部性</p>
</li>
<li><p>内外循环交换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;每次循环调入一个大块，可能发生容量不命中和冲突不命中</span><br><span class="line">for(j&#x3D;0; j&lt;100; j++)&#123;</span><br><span class="line">	for(i&#x3D;0; i&lt;5000; i++)&#123;</span><br><span class="line">		x[i][j] &#x3D; 2*x[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;修改后，可以访问同一块中的各个元素，再访问下一个块</span><br><span class="line">for(i&#x3D;0; i&lt;5000; i++)&#123;</span><br><span class="line">	for(j&#x3D;0; j&lt;100; j++)&#123;</span><br><span class="line">		x[i][j] &#x3D; 2*x[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环融合：将若干个独立的循环融合为单个的循环。这些循环访问同样的数组，对相同的数据作不同的运算。这样能使得读入cache的数据在被替换出去之前，能得到反复的使用 </p>
</li>
<li><p>分块：把对数组的整行或整列访问改为按块进行。有助于寄存器分配，可以把load和store操作的次数变成最小。例如矩阵乘法，若行列较多，可以通过分块计算</p>
</li>
</ul>
<h4 id="“牺牲”cache"><a href="#“牺牲”cache" class="headerlink" title="“牺牲”cache"></a>“牺牲”cache</h4><p>一种能减少冲突不命中次数而又不影响时钟频率的方法</p>
<p>基本思想：在cache和它从下一级存储器调数据的通路之间设置一个全相联的小cache，称为“牺牲”Cache（Victim Cache）。用于存放被替换出去的块(称为牺牲者)，以备重用</p>
<p>作用：对于减小冲突不命中很有效，特别是对于小容量的直接映象数据Cache，作用尤其明显</p>
<h3 id="减少cache不命中开销"><a href="#减少cache不命中开销" class="headerlink" title="减少cache不命中开销"></a>减少cache不命中开销</h3><h4 id="采用两级cache"><a href="#采用两级cache" class="headerlink" title="采用两级cache"></a>采用两级cache</h4><p>第一级cache小而快，第二级cache容量大</p>
<p>平均访存时间＝ 命中时间L1＋不命中率L1×不命中开销L1</p>
<p>不命中开销L1＝ 命中时间L2＋不命中率L2×不命中开销L2</p>
<ul>
<li>局部不命中率：该级Cache的不命中次数/到达该级cache的访问次数</li>
<li>全局不命中率：该级Cache的不命中次数/CPU发出的访存的总次数</li>
</ul>
<p>每条指令的平均访存停顿时间＝ 每条指令的平均不命中次数L1×命中时间L2＋每条指令的平均不命中次数L2×不命中开销L2</p>
<p>对于第二级cache</p>
<ul>
<li>在第二级cache比第一级 cache大得多的情况下，两级cache的全局不命中率和容量与第二级cache相同的单级cache的不命中率非常接近</li>
<li>局部不命中率不是衡量第二级cache的一个好指标，因此，在评价第二级cache时，应用全局不命中率这个指标</li>
</ul>
<p>第二级cache参数</p>
<ul>
<li>容量：第二级Cache的容量一般比第一级的大许多，意味着第二级cache可能实际上没有容量不命中，只剩下一些强制性不命中和冲突不命中</li>
<li>相联度：第二级Cache可采用较高的相联度或伪相联方法</li>
<li>块大小：<ul>
<li>第二级cache可采用较大的块</li>
<li>为减少平均访存时间，可以让容量较小的第一级cache采用较小的块，而让容量较大的第二级cache采用较大的块</li>
<li>多级包容性：第一级cache中的数据是否总是同时存在于第二级cache中</li>
</ul>
</li>
</ul>
<h4 id="让读不命中优先于写"><a href="#让读不命中优先于写" class="headerlink" title="让读不命中优先于写"></a>让读不命中优先于写</h4><p>cache中的写缓冲器导致对存储器访问的复杂化。在读不命中时，所读单元的最新值有可能还在写缓冲器中，尚未写入主存。</p>
<p>解决方法</p>
<ul>
<li>可推迟对读不命中的处理，直至写缓冲器清空。</li>
<li>在读不命中时检查写缓冲器内容，若没有冲突而且地址可以访问，就可以处理读不命中（让读不命中优先于写）</li>
</ul>
<h4 id="写缓冲合并"><a href="#写缓冲合并" class="headerlink" title="写缓冲合并"></a>写缓冲合并</h4><ul>
<li>如果写缓冲器为空，就把数据和相应地址写入该缓冲器</li>
<li>如果写缓冲器中已经有了待写入的数据，就要把这次的写入地址与写缓冲器中已有的所有地址进行比较，看是否有匹配的项。如果有地址匹配而对应的位置又是空闲的，就把这次要写入的数据与该项合并。这就叫写缓冲合并</li>
<li>如果写缓冲器满且又没有能进行写合并的项，就必须等待</li>
</ul>
<p><img src= "/amumu547426.github.io/img/loading.gif" data-src="https://i.loli.net/2020/07/12/GPuLBMN85wdYsAF.png" alt="写缓冲合并.png"></p>
<p>待写入数据连续，可以合并</p>
<p>提高了写缓冲器的空间利用率，而且还能减少因写缓冲器满而要进行的等待时间</p>
<h4 id="请求字处理技术"><a href="#请求字处理技术" class="headerlink" title="请求字处理技术"></a>请求字处理技术</h4><p>请求字：从下一级存储器调入cache的块中，只有一个字是立即需要的。这个字称为请求字</p>
<p>应尽早把请求字发送给CPU</p>
<ul>
<li>尽早重启动：调块时，从块的起始位置开始读起。一旦请求字到达，就立即发送给CPU，让CPU继续执行</li>
<li>请求字优先：调块时，从请求字所在的位置读起。这样，第一个读出的字便是请求字。将之立即发送给CPU</li>
</ul>
<p>cache块小或是下条指令正好访问同一cache块的另一部分情况下效果不大</p>
<h4 id="非阻塞cache技术"><a href="#非阻塞cache技术" class="headerlink" title="非阻塞cache技术"></a>非阻塞cache技术</h4><p>非阻塞cache：cache不命中时仍允许CPU进行其它的命中访问。即允许“不命中下命中”</p>
<p>可以同时处理的不命中次数越多，所能带来的性能上的提高就越大，但并不是不命中次数越多越好</p>
<h3 id="减少命中时间"><a href="#减少命中时间" class="headerlink" title="减少命中时间"></a>减少命中时间</h3><h4 id="容量小、结构简单的cache"><a href="#容量小、结构简单的cache" class="headerlink" title="容量小、结构简单的cache"></a>容量小、结构简单的cache</h4><ul>
<li>硬件越简单，速度就越快</li>
<li>应使cache足够小，以便可以与CPU一起放在同一块芯片上</li>
</ul>
<h4 id="虚拟cache"><a href="#虚拟cache" class="headerlink" title="虚拟cache"></a>虚拟cache</h4><ul>
<li><p>物理cache：使用物理地址进行访问的传统Cache。标识存储器中存放的是物理地址，进行地址检测也是用物理地址。地址转换和访问cache串行进行，访问速度很慢</p>
</li>
<li><p>虚拟cache：可以直接用虚拟地址进行访问的cache。标识存储器中存放的是虚拟地址，进行地址检测用的也是虚拟地址。优点：在命中时不需要地址转换，省去了地址转换的时间。即使不命中，地址转换和访问cache也是并行进行的，其速度比物理cache快很多</p>
</li>
<li>虚拟索引+物理标识<ul>
<li>虚地址的页内位移作为访问cache的索引（不作虚-实转换），标识是物理的地址</li>
</ul>
</li>
</ul>
<h4 id="cache访问流水化"><a href="#cache访问流水化" class="headerlink" title="cache访问流水化"></a>cache访问流水化</h4><p>对第一级Cache的访问按流水方式组织，访问cache需要多个时钟周期才可以完成</p>
<h4 id="踪迹cache"><a href="#踪迹cache" class="headerlink" title="踪迹cache"></a>踪迹cache</h4><p>开发指令级并行性所遇到的一个挑战是当要每个时钟周期流出超过4条指令时，要提供足够多条彼此互不相关的指令是很困难的</p>
<p>一个解决办法：踪迹cache</p>
<ul>
<li>存放CPU所执行的动态指令序列。包含了由分支预测展开的指令，该分支预测是否正确需要在取到该指令时进行确认</li>
</ul>
<h2 id="并行主存系统"><a href="#并行主存系统" class="headerlink" title="并行主存系统"></a>并行主存系统</h2><p>是在一个访存周期内能并行访问多个存储字的存储器，它能有效地提高存储器的带宽</p>
<h3 id="单体多字存储器"><a href="#单体多字存储器" class="headerlink" title="单体多字存储器"></a>单体多字存储器</h3><p><img src= "/amumu547426.github.io/img/loading.gif" data-src="https://i.loli.net/2020/07/12/bUoGhac6YAtE2iD.png" alt="单体多字.png"></p>
<p>m=4，一次性读出4个字到寄存器</p>
<h3 id="多体交叉存储器"><a href="#多体交叉存储器" class="headerlink" title="多体交叉存储器"></a>多体交叉存储器</h3><p><img src= "/amumu547426.github.io/img/loading.gif" data-src="https://i.loli.net/2020/07/12/ZAPOTBSIE4d2zRa.png" alt="多体交叉.png"></p>
<p>m=4，4个存储体，一次性可以读出4个体同一个体内地址的内容</p>
<p>编址方法有高位交叉编址和低位交叉编址。高位交叉编址体号在高位，低位交叉编址体号在低位。</p>
<p>假设m个体，体内n个存储单元，给定一个地址A</p>
<ul>
<li>高位交叉编址：体号j=⌊A/n⌋，体内地址i=A mod n</li>
<li>低位交叉编址：体号j=A mod m，体内地址i=⌊A/m⌋</li>
</ul>
<h3 id="避免存储器冲突"><a href="#避免存储器冲突" class="headerlink" title="避免存储器冲突"></a>避免存储器冲突</h3><p>体冲突：是指两个访问请求要访问同一个存储体。在传统的多体交叉结构中，顺序访问被处理得很好，不会发生体冲突。地址相差奇数值的访存也是如此</p>
<p>而地址相差偶数值时，冲突频度增加了，解决问题的一种办法是用更多的体来减少体冲突的次数，但这种方法不会完全避免。</p>
<p>例如：假设有128个存储体，按字交叉方式工作，执行以下程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x[256][512];</span><br><span class="line">for(j&#x3D;0；j&lt;512；j&#x3D;j+1) </span><br><span class="line">for(i&#x3D;0；i&lt;256；i&#x3D;i+1) </span><br><span class="line">   x[i][j]&#x3D;2*x[i][j]</span><br></pre></td></tr></table></figure>
<p>512是128的整数倍，同一列内所有元素都在同一体内，会频繁产生cache不命中。可以让程序员或编译器来扩展数组大小使其不是2的幂从而强制使上述地址落在不同的体内</p>
<h4 id="另一种硬件方法"><a href="#另一种硬件方法" class="headerlink" title="另一种硬件方法"></a>另一种硬件方法</h4><p>（低位交叉）对于给定地址A，体数m，体内容量n，为了减少体冲突，令m为素数</p>
<p>顺序交叉：体号j=A mod m，体内地址i=⌊A/m⌋</p>
<p>取模交叉：体内地址i=A mod n，体号j=A mod m（用素数取模）</p>
<p><img src= "/amumu547426.github.io/img/loading.gif" data-src="https://i.loli.net/2020/07/12/yFcfVZjadg6xTE3.png" alt="顺序交叉与取模交叉.png"></p>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>虚拟存储器分为两类：段式和页式</p>
<p>分页：页式虚拟存储器把空间划分为大小相同的块。页面是对空间的机械划分。信息的物理单位</p>
<p>分段：虚拟存储器则把空间划分为可变长的块。而段则往往是按程序的逻辑意义进行划分的。信息的逻辑单位</p>
<p>现代计算机大多段页式组合，每段被划分为若干个页，保存段作为逻辑单位的优点．又简化了替换的实现，而且段不必作为整体全部—次调入主存，可以以页面为单位部分调入</p>
<h3 id="快速地址转换技术"><a href="#快速地址转换技术" class="headerlink" title="快速地址转换技术"></a>快速地址转换技术</h3><p>由页表管理，页表一般很大，是存放在主存中的。—般采用TLB来解决这个问题</p>
<p>TLB（Translation Look-aside Buffer）地址变换高速缓存：</p>
<ul>
<li>—个专用的高速缓冲器，用于存放近期经常使用的页表项(Page Table Entry，PTE页表条目)。根据程序的局部性原理，它所用的页表条目也是聚集的</li>
<li>这样，大多数访存都可以通过TLB快速地完成虚—实地址转换，只有偶尔在ALU不命中时，才需要去访问主存中的页表</li>
</ul>
<p>TLB中的项由两部分构成：标识和数据</p>
<ul>
<li>标识：存放的是虚地址的一部分</li>
<li>数据：存放的则是物理页帧号：有效位、存储保护信息、使用位、修改位等</li>
</ul>
<p>为了使TLB中的内容与页表保持一致，当修改页表的某—项时，操作系统必须保证TLB中没有该页表项的副本。这可以通过作废TLB中的页表项来实现</p>
<p>下图为AMD Opteron的数据TLB的组织结构</p>
<p><img src= "/amumu547426.github.io/img/loading.gif" data-src="https://i.loli.net/2020/07/12/rfWedsLiECMVzJB.png" alt="TLB.png"></p>
<p>进行地址转换时，把虚拟地址送往各个标识，同时进行比较。若存在匹配的标识，则多路选择器把相应TLB项中的物理地址选出</p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/amumu547426.github.io/tags/cache/">cache</a><a class="post-meta__tags" href="/amumu547426.github.io/tags/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/">虚拟存储器</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/07/12/cPFZusrglJCTVKz.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/amumu547426.github.io/2020/07/12/%E6%8C%87%E4%BB%A4%E7%BA%A7%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95-%E7%A1%AC%E4%BB%B6%E6%96%B9%E6%B3%952/"><img class="next-cover" data-src="https://i.loli.net/2020/07/12/IzxuPA2BKF7UrXD.jpg" onerror="onerror=null;src='/amumu547426.github.io/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">指令级并行开发方法-硬件方法2</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'bBew5zit71oYgat9bmNjTI8Y-gzGzoHsz',
  appKey: 'Mzi1bqj9diHLCiqQiXhOcHw6',
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/07/12/cPFZusrglJCTVKz.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Haunting</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/amumu547426.github.io/js/utils.js"></script><script src="/amumu547426.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="ribbon_piao" mobile="false" src="/amumu547426.github.io/js/third-party/piao.js"></script><script src="/amumu547426.github.io/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/amumu547426.github.io/js/third-party/click_heart.js"></script><script src="/amumu547426.github.io/js/third-party/ClickShowText.js"></script><script src="/amumu547426.github.io/js/search/local-search.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>